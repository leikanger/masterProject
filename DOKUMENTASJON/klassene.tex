
\section{Klassestruktur}
Klassene er bygd opp som i uml-klassediagrammet i loggboka. I tillegg tenker eg å ha interface-klasser for auron og synapse

Forskjellen mellom SANN og KANN er måten aktiviteten propagerer. Dersom eg da har eit aktivitetsObj med relevante funskjoner (som sendSignal(), getDepol(), osv), så kan synapse, dendrite og auron være det samme for ANN og SANN (bare med ulikt aktivitetsObj (nedarva fra i\_aktivitetsObj, som er interfaceklasse for begge aktivitetsObj--typer).


\subsection{interfaceklasser}
For å få det så generellt som mulig, lager eg ei interface-klasse (f.eks. i\_auron) som er generalisering av spiking auron og $\kappa$ auron. Samme for alle auron--element (synapse,auron(soma),axon, dendrite).

Interfaceklassen inneholder alle funksjoner og variabler som er generellt for begge underklassene, dvs alle de funksjoner og variabler som får ANN til å gå.





\subsection{peikere}
Siden eg heile tida opererer med peikere, og lager alle objekt i det frie lageret, trenger eg å eksplisitt kalle destruktor.
Siden synapse kvar synapse er tilknytta bare en presynatisk og en postsynaptisk node, begynner eg destrueringa her. Når f.eks. eit axon skal destrueres går eg gjennom alle pUtSynapser--element, og destruerer.
\begin{lstlisting}
while( !pUtSynapser.empty() )
	delete ( *pUtSynapser.begin() )
\end{lstlisting}
